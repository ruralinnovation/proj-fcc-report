---
title: "EDA on ISP"
date: last-modified
format: 
  html:
    code-fold: true
engine: knitr
---

```{r}
#| label: utility functions
source("R/table_with_options.R")
```

We are starting a first exploratory data analysis around ISPs in the FCC BDC data set. It should be kept in mind that an ISP can be multiple time in the same location (offering multiple service).

Our goal is being able to take FCC data and correctly identify an ISP over time (from the same program and from other FCC product).

How can we define an ISP? How can we define coverage, should a service 0/0 be considered as a coverage?

We shifted a bit from exploring to try to classify the quality of information we have from FCC about ISP.

The query that generated the data set is here: 

```SQL
select 
    frn,
    provider_id,
    brand_name,
    count(distinct location_id) as cnt_locations,
    count(*) as cnt_locations_services,
    bool_or(case when technology = 10 then true else false end) as has_copperwire,
    bool_or(case when technology = 40 then true else false end) as has_coaxial_cable,
    bool_or(case when technology = 50 then true else false end) as has_fiber,	
    bool_or(case when technology >= 70 then true else false end) as has_wireless,
    bool_or(case when technology = 60 or  technology = 61 then true else false end) as has_satel,
    array_agg(distinct state_abbr)
from staging.june23
group by frn, provider_id, brand_name
```

The name of the column match FCC [description](https://us-fcc.app.box.com/v/bdc-data-downloads-output). 

We are adding: 

-  `cnt_locations_services`: count of **services**, in one location you can have multiple services with different providers, technology and speeds provides (sometimes one providers can have multiple technology and/or multiple speeds) 

- `cnt_locations`: count of locations covered by this specific set of brand_name, provider_id, state_abbr and technology (here if a provider declare providing different speed in that location it will not be counted) 

- a serie of flag (`has`) telling if this "combo" is proving said technology

- an array listing in which states are present our "combo"

We have from FCC: 

:::{.aside}
source: https://us-fcc.app.box.com/v/bdc-data-downloads-output page 4
:::

- `frn` **F**CC **R**egistration **N**umber; "number of the entity that submited the data". It is supposed to be a string of 10 characters (with padding 0). 

- `provider_id`: "unique identifier for the fixed service provider"

- `brand_name`: "Name of the entity or service advertised or offered to consumers."

```{r}
#| label: read and display ISP  
isp <- read.csv("data/isp.csv",
                colClasses = c(frn ="character",
                               provider_id = "character",
                               brand_name = "character",
                               cnt_locations = "character",
                               cnt_locations_services = "character",
                               has_copperwire = "logical",
                               has_coaxial_cable = "logical",
                               has_fiber = "logical",
                               has_wireless = "logical",
                               has_satel = "logical",
                               array_agg = "character"))

isp[["cnt_locations"]] <- as.numeric(isp[["cnt_locations"]])                               
isp[["cnt_locations_services"]] <- as.numeric(isp[["cnt_locations_services"]])  

table_with_options(isp)
``` 

## Numbers for context: 

### Raw numbers out of the box:

```{r}
sprintf("Number of unique frn: %s", length(unique(isp[["frn"]])))
sprintf("Number of unique provider_id; %s", length(unique(isp[["provider_id"]])))
sprintf("Number of unique brand name pre cleaning: %s", length(unique(isp[["brand_name"]])))
```

if we remove all capitalization and change underscore for white space:

```{r}
count_and_clean <- function(vec) {
  length(unique(tolower(trimws(gsub("_", " ", vec)))))} 

num_brand_name <- count_and_clean(isp[["brand_name"]])
sprintf("Number of unique brand name w/o caps and no underscore: %s", num_brand_name)
```

We can filter, on this release, 24 cases for brand name.

```{r}
isp[["clean_name"]] <- tolower(trimws(gsub("_", " ", isp[["brand_name"]]))) 
```

### Potential sources of errors:

- frn can be wrong  
- provider_id can be wrong 
- brand name can be different 

One case: 

| frn | provider_id| brand_name| cnt_locations | cnt_locations_services | has_copperwire | has_coaxial_cable | has_fiber | has_wireless | has_satel | array_agg | 
|---- | ---- | --- | --- | --- | ---- | ----| --- | --- | ----| ----| ---- | --- | 
|0003738655	| 130432 	| "EATEL Corp." |	83537	| 86548 |	true	| true |	true |	false	| false |	{LA} |
| 0009873712	| 131103 	| "EATEL Corp."	| 34494	| 34497	| false	| true | true |	false	| false |	{LA} |

Other case: 

| frn | provider_id| brand_name| cnt_locations | cnt_locations_services | has_copperwire | has_coaxial_cable | has_fiber | has_wireless | has_satel | array_agg | 
|---- | ---- | --- | --- | --- | ---- | ----| --- | --- | ----| ----| ---- | --- | 
| 0002626984 |130008 | 	Acentek |	47 |	47	| true|	false |	true |	false |	false |	{MN} |
| 0002626984 |	130008 |  ACENTEK	| 1395 |	1395	| true |	false	| false	| false |	false |	{MN} |
| 0002645927 |	130008 |	Acentek	| 19521	| 26636 | true	|false	|true|	true |	false | 	{IA,MN} |


### Rules for problems: 

#### Less than 2 locations

```{r}
#| label: less than 2 locations
isp[["few_locations"]] <- NA_character_
isp[isp[["cnt_locations"]] < 2, "few_locations"] <- "few locations"
few_locations_dat <- subset(isp, few_locations == "few locations")
few_rows <- nrow(few_locations_dat)
sprintf("Rows with less than two locations: %s", few_rows)

print("brand_names concerned:")
unique(few_locations_dat$brand_name)
```

An easy fix is to drop them.

#### More than one frn for a provider_id

```{r}
#| label: more than one frn for a provider
temp <- sapply(split(isp$frn, isp$provider_id), function(x) length(unique(x)))

dta <- data.frame(provider_id = names(temp), frn_by_provider_id = temp)

# correct lower/upper case / replace underscore by  " "  / some white space on both side 
# triming whispace did not improve for this dataset but I should keept doing it
dta[["unique_brand_name_by_provider_id"]] <-  sapply(split(isp$brand_name, isp$provider_id),
                                      count_and_clean)
dta[["same_state_by_provider_id"]] <- sapply(split(isp$array_agg, isp$provider_id), function(x) length(unique(x))) 

isp <- merge(isp, dta, by.x = "provider_id", by.y = "provider_id",
             all.x = TRUE, all.y = TRUE)
more_frn_than_provider <- subset(isp, isp$frn_by_provider_id  > 1)

table_with_options(more_frn_than_provider)
```

Unique provider_id + brand_name are kind of "green" (for one time frame):

```{r}
sprintf("Number of green isp: %s", nrow(isp[isp$unique_brand_name_by_provider_id == 1,]))
```

We can have one `provider_id` with multiple `frn` and same or not `brand_name` (see TSC for example / 150266) 

It seems:

- Windstream has 37 different `frn`:  we can maybe test if it has windstream in it's name ..

- Otelco/GoNet (18 cases)

- Rally Networks/Oregon Telephone Company, is their frn wrongs ? (17 cases)

- Same Provider for differents `frn` and  `brand_name` in Minesota (MN) (16 cases)

- `160127` I do not see any kind of specific pattern for this one

- `131486` seems to be RiverStreet Networks with various `frn` (13 cases) -> will be catch by unique_brand_name_by_provider_id

- `190233` multiple brand name and frn but seems to be in Texas and  Oklahoma (13)

- `131226` seems to be Fastwyre Broadband divided by technology and states (12 cases) -> will be catch by unique_brand_name_by_provider_id 

- `130804` seems to be Mediacom (+ Bolt) with different states and names indicating their states (11 cases) 

- Google Fiber (`240041`) seems to be have `frn` split by states (with a weird 'Webpass, Inc.') (11 cases) -> will be catch by unique_brand_name_by_provider_id (except Webpass, Inc which is weird, technology is 70 that I should correct) 

- AT&T Inc (`130077`) multiple frn (10 cases) -> filter by unique_brand_name_by_provider_id 

- 130079  = Astound_Broadband (10 cases) -> will be catch by unique_brand_name_by_provider_id 

- Verizon -> filter by unique_brand_name_by_provider_id 

- long ling  (130757 ) & co are problematics (multiples names / one provider / 3 states )

- `130906`  is also hard to fix

Assuming that same name (clean version) + same `provider_id` provide us with a unique ISP, it helps move to greensih: 

```{r}
table_with_options(more_frn_than_provider[more_frn_than_provider$unique_brand_name_by_provider_id == 1,])
```

This is removing 194 out of 1170. 

#### Same provider_id and same states

Not too sure about this one. 

#### More than one provider_id for a cleaned brand name

This is the case for "EATEL".

```{r}
temp <- sapply(split(isp$provider_id, isp$clean_name),
         function(x) length(unique(x)))
dta <- data.frame(clean_name = names(temp), provider_id_by_clean_name = temp)
isp <- merge(isp, dta, by.x = "clean_name", by.y = "clean_name",
             all.x = TRUE, all.y = TRUE)

provider_id_by_clean_name <- subset(isp, isp$provider_id_by_clean_name  > 1)

table_with_options(provider_id_by_clean_name)
```

This could also move 63 cases in the greenish spot. -> nop

## What are our options/next steps:

- Make a column "ready to go"

```{r}
# if it has unique brand name and frn by provider id id should be good
temp <- isp$frn_by_provider_id + isp$unique_brand_name_by_provider_id
isp[["rdy_to_go"]] <- ifelse(temp == 2, "green", "not green")

# cases where we have a unique frn and provider id but not unique brand name 
# default of olive is that we need to pick a name out of more than one
temp <- ifelse(isp$frn_by_provider_id == 1, 1, 0) + ifelse(isp$unique_brand_name_by_provider_id > 1, 1, 0)
isp[temp == 2, "rdy_to_go"] <- "olive"

# the few locations should be "red" and maybe dropped later 
isp[which(isp$few_locations == "few locations"), "rdy_to_go"] <- "red"

table_with_options(isp)
```


A good example could be `131167` and how we can discriminate Orbitel communications. We can also prob raise the bar of "few locations". 

A quick summary of where we are:

```{r}
table(isp[["rdy_to_go"]])
```


- Make an id <---> provider_id / frn / brand_name table 

