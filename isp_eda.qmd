---
title: "EDA on ISP"
date: last-modified
format: 
  html:
    code-fold: true
engine: knitr
---

```{r}
#| label: utility functions
source("R/table_with_options.R")
```

We are starting a first exploratory data analysis around ISPs in the FCC BDC data set. It should be kept in mind that an ISP can be multiple time in the same location (offering multiple service).

Our goal is being able to take FCC data and correctly identify an ISP over time (from the same program and from other FCC product).

We shifted a bit from exploring to try to classify the quality of information we have from FCC about ISP.

The query that generated the data set is here: 

```SQL
select 
    frn,
    provider_id,
    brand_name,
    count(distinct location_id) as cnt_locations,
    count(*) as cnt_locations_services,
    bool_or(case when technology = 10 then true else false end) as has_copperwire,
    bool_or(case when technology = 40 then true else false end) as has_coaxial_cable,
    bool_or(case when technology = 50 then true else false end) as has_fiber,	
    bool_or(case when technology = 71 or  technology = 72 then true else false end) as has_wireless,
    bool_or(case when technology = 60 or  technology = 61 then true else false end) as has_satel,
    array_agg(distinct state_abbr)
from staging.june23
group by frn, provider_id, brand_name
```

The name of the column match FCC [description](https://us-fcc.app.box.com/v/bdc-data-downloads-output). 

We are adding: 

-  `cnt_locations_services`: count of **services**, in one location you can have multiple services with different providers, technology and speeds provides (sometimes one providers can have multiple technology and/or multiple speeds) 

- `cnt_locations`: count of locations covered by this specific set of brand_name, provider_id, state_abbr and technology (here if a provider declare providing different speed in that location it will not be counted) 

- a serie of flag (`has`) telling if this "combo" is proving said technology

- an array listing in which states are present our "combo"

We have from FCC: 

:::{.aside}
source: https://us-fcc.app.box.com/v/bdc-data-downloads-output page 4
:::

- `frn` **F**CC **R**egistration **N**umber; "number of the entity that submited teh data". It is supposed to be a string of 10 characters (with padding 0). 

- `provider_id`: "unique identifier for the fixed service provider"

- `brand_name`: "Name of the entity or service advertised or offered to consumers."

```{r}
#| label: read and display ISP  
isp <- read.csv("data/isp.csv",
                colClasses = c(frn ="character",
                               provider_id = "character",
                               brand_name = "character",
                               cnt_locations = "character",
                               cnt_locations_services = "character",
                               has_copperwire = "logical",
                               has_coaxial_cable = "logical",
                               has_fiber = "logical",
                               has_wireless = "logical",
                               has_satel = "logical",
                               array_agg = "character"))

isp[["cnt_locations"]] <- as.numeric(isp[["cnt_locations"]])                               
isp[["cnt_locations_services"]] <- as.numeric(isp[["cnt_locations_services"]])  

table_with_options(isp)
``` 

## Numbers for context: 

### Raw numbers out of the box:

```{r}
sprintf("Number of unique frn: %s", length(unique(isp[["frn"]])))
sprintf("Number of unique provider_id; %s", length(unique(isp[["provider_id"]])))
sprintf("Number of unique brand name pre cleaning: %s", length(unique(isp[["brand_name"]])))
```

if we remove all capitalization:

```{r}
sprintf("Number of unique brand name w/o caps: %s", length(unique(tolower(isp[["brand_name"]]))))
```

We can filter, on this release, 21 cases for brand name.

### Potential sources of errors:

- frn can be wrong  
- provider_id can be wrong 
- brand name can be different 

One case: 

| frn | provider_id| brand_name| cnt_locations | cnt_locations_services | has_copperwire | has_coaxial_cable | has_fiber | has_wireless | has_satel | array_agg | 
|---- | ---- | --- | --- | --- | ---- | ----| --- | --- | ----| ----| ---- | --- | 
|0003738655	| 130432 	| "EATEL Corp." |	83537	| 86548 |	true	| true |	true |	false	| false |	{LA} |
| 0009873712	| 131103 	| "EATEL Corp."	| 34494	| 34497	| false	| true | true |	false	| false |	{LA} |

Other case: 

| frn | provider_id| brand_name| cnt_locations | cnt_locations_services | has_copperwire | has_coaxial_cable | has_fiber | has_wireless | has_satel | array_agg | 
|---- | ---- | --- | --- | --- | ---- | ----| --- | --- | ----| ----| ---- | --- | 
| 0002626984 |130008 | 	Acentek |	47 |	47	| true|	false |	true |	false |	false |	{MN} |
| 0002626984 |	130008 |  ACENTEK	| 1395 |	1395	| true |	false	| false	| false |	false |	{MN} |
| 0002645927 |	130008 |	Acentek	| 19521	| 26636 | true	|false	|true|	true |	false | 	{IA,MN} |


### Rules for problems: 

#### less than 2 locations

```{r}
#| label: less than 2 locations
isp[["few_locations"]] <- NA_character_
isp[isp[["cnt_locations"]] < 2, "few_locations"] <- "few locations"
few_locations_dat <- subset(isp, few_locations == "few locations")
few_rows <- nrow(few_locations_dat)
sprintf("Rows with less than two locations: %s", few_rows)

print("brand_names concerned:")
unique(few_locations_dat$brand_name)
```


#### More than one frn for a provider_id

```{r}
#| label: more than one frn for a provider
temp <- sapply(split(isp$frn, isp$provider_id), function(x) length(unique(x)))

dta <- data.frame(provider_id = names(temp), muli_frn = temp)

isp <- merge(isp, dta, by.x = "provider_id", by.y = "provider_id",
             all.x = TRUE, all.y = TRUE)

more_frn_than_provider <- subset(isp, muli_frn > 1)

table_with_options(more_frn_than_provider)
```


- same frn but more than one provider_id

- frn and/or provider_id with more than one row 
